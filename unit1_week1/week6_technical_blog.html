<!Doctype html>
<html>
  <head><h2>Functional vs. Object-Oriented Programming</h2>
  <link rel="stylesheet" type="text/css" href="/unit1_week1/stylesheets/stylesheet_for_blog.css">
  <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
  </head>
    <body>

      <h4>Procedural, and imperative, and declarative, and encapsulation, and orthogonal, and lambdas, and state, and side effects...Who's in way over her head when it comes to these Functional vs. OOP discussions? This girl.</h4>

    <div id="main">
      <p>When researching the difference between functional and object-oriented programming, I did what most people would do: I googled it. I looked through some sources, got an idea of what each programming paradigm entailed (sort of), and then started researching more in-depth.</p> 

      <p>Well here's the thing: for a n00b like myself, some of the conversations I found about various programming styles were totally above my head. I had to go and look up many MANY terms, but I also just don't have the CS background to know WTF some of these people are talking about.</p> 

      <p>Here's a perfect example of the kind of trash (err, knowledgeable discourse) I found: </p> 

      <blockquote> "Functional programming is based on a declarative model and has its roots from lambda calculus. It offers a lot of great concepts which can be borrowed from more imperative languages like C++ and C#.<br /><br />

      Some examples include referential transparency, lambda functions, first class functions, lazy and eager evaluation, and immutability.<br /><br />

      If for nothing else learning functional programming is useful for the concepts that it contains. It will change the way you do programming and think about programming. And I would guess that in the future functional programming will be just as important as object oriented programming has been.<br /><br />

      <strong>What are some of the big differences, pros and cons of functional programming vs. object-oriented programming?</strong><br /><br />

      Well object oriented programming is nice because it allows you to model your complex problem into hierarchies so you can simplify the problem. But it becomes very hard when you start to consider multi threaded programming while using mutable objects. In such cases you need to use heavy use of synchronization objects and it's near impossible to perfect a large application.<br /><br />

      That's where functional programming comes in. Because of things like immutability functional programming really simplifies multi-threaded programs. It makes it almost trivially easy to parallelize something when you know that given input X to a function it will always output Y. Also you know that a variable (or value in functional programming) can't change mid use from another thread."</blockquote>

      <p>Ohhhhhhhhhhhhhhhhh, okay, I get it! Why didn't you just say "referential transparency" in the first place!? I mean, what kind of idiot isn't intimately familiar with lambda calculus? What is this, amateur hour?</p> 

      <p>Stop it, already.</p>

      <img src="http://cdn.gifstache.com/2012/12/5/gifstache_2975_1354730400.gif" style="width: 300px">

      <p>I'm obviously being facetious, and I totally got some useful info from that quote, but my frustration lies in all the stuff I just don't really understand (like lazy and eager evaluation, etc.). While I can see how, in theory, mutable vs. immutable objects function, I really don't have a deep grasp of how to tell what is mutable, what is immutable, and HOW to implement those states. Speaking of states, it seems easy enough, but umm, what? Here's another stackoverflow.com example: </p>

      <blockquote>"I have heard this time and again, and I am trying to understand and validate the idea that FP and OO are orthogonal. First of all, what does it mean for 2 concepts to be orthogonal? FP encourages immutability and purity as much as possible, while OO seems built for state and mutation – a slightly organized version of imperative programming? I realize that objects can be immutable, but OO seems to imply state/change to me. They seem like opposites. How does that affect their orthogonality? A language like Scala makes it easy to do OO and FP both, does this affect the orthogonality of the two methods?"</blockquote>

      <p>And here's the answer:</p>

      <blockquote>"Orthogonality implies that two things are unrelated. It comes from mathematics where it means perpendicular. In common usage it can mean two decisions are unrelated or that one subject is irrelevant when considering another subject. As used here, orthogonal means that one concept doesn't either imply or exclude the other.<br /><br />

      The two concepts object oriented programming and functional programming are not incompatible with each other. Object orientedness does not imply mutability. Many people who are introduced to object oriented programs the traditional way often first use C++, Java, C# or similar languages where mutability is common and even encouraged (standard libraries provide a variety of mutable classes for people to use). Therefore it is understandable that many people associate object oriented programming with imperative programming and mutability, as this is how they have learned it. <br /><br />

      However object oriented programming covers topics like: Encapsulation, Polymorphism, and Abstraction. None of this implies mutability, and none of it excludes functional programming. So yes they are orthogonal in that they are different concepts. They are not opposites - you can use one, or the other, or both (or even neither)."</blockquote>

      <p>At this point, I'm lost. I feel like I need to find much better resources and definitions, and maybe a map that can show me how all these concepts work together. Because at this here moment in time I'm all: </p>

      <img src="http://www.reactiongifs.com/wp-content/gallery/wtf/wedding-crashers-wtf.gif">

      <p>I know what you're thinking. Enough with the gifs already. Let's get back to business.</p>

      <p>Here are some legitimate definitions that I found:</p>

      <ul>
        <li>FUNCTIONAL PROGRAMMING: is when functions, not objects or procedures, are used as the fundamental building blocks of a program (think of Ruby's methods, but not used on classes). Functional programming emphasizes functions that produce results that depend only on their inputs and not on the program state—i.e. pure mathematical functions. It is a declarative programming paradigm, which means programming is done with expressions. In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) both times. Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.
        </li>
        <li>OBJECT-ORIENTED PROGRAMMING: is a programming language model organized around objects rather than "actions" and data rather than logic. Rather than structure programs as code and data, an object-oriented system integrates the two using the concept of an "object". An object has state (data) and behavior (code). Objects correspond to things found in the real world. So for example, a graphics program will have objects such as circle, square, menu. An online shopping system will have objects such as shopping cart, customer, product. The shopping system will support behaviors such as place order, make payment, and offer discount. The objects are designed as class hierarchies. So, for example, with the shopping system there might be high level classes such as electronics product, kitchen product, and book. There may be further refinements for example under electronic products: CD Player, DVD player, etc. These classes and subclasses correspond to sets and subsets in mathematical logic.  
        </li>
      </ul>

      <p>To recap, it seems like OOP is focused more on having users and interacting with those users; it accommodates real-world scenarios where things are constantly in flux. Functional programming, on the other hand, does not like flux. It is therefore more exact in some ways; if there is ever only one input and one output, you will always be assured that those two values do not change. However, I've read multiple articles that claim using functional programming styles in OOP is the wave of the future. This is an excellent article/blog about just that (with examples using Ruby and Haskell - side note, Haskell is crazy-looking):<a href="http://www.harukizaemon.com/blog/2010/03/01/functional-programming-in-object-oriented-languages/">Functional Programming in Object-Oriented Languages</a></p>

      <p>After reading all this stuff, I now sort-of understand functional programming, just like I sort of understand OOP. I'm hoping to re-visit this topic in a year, try Clojure, and see what happens.</p>

      <p>Lastly, here are some other good references about functional programming, if you're not sick of reading about it yet:</p>
      <ul>
        <li><a href="https://docs.python.org/2.7/howto/functional.html">Functional Programming How-to</a></li>
        <li><a href="https://www.coursera.org/course/progfun">Functional Programming Principles: Coursera</a></li>
        <li><a href="http://www.cs.nott.ac.uk/~gmh/fun.html">Set of slides from Chapter 1: Introduction</a></li>
      </ul>

	</div>
   <div id="nav">
    <a href="../index.html">Home</a><br />
    <a href="week6_cultural_blog.html">Next Blog</a><br />
    <a href="week5_cultural_blog.html">Previous Blog</a><br />
  </div>


  </body>
</html>


